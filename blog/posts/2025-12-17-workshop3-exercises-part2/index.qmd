---
title: "Workshop 3 Preview: Remote Connectivity & Security (Exercises 4-5)"
subtitle: "Part 2 of 3: Cloud Routers and mTLS for Secure Robot Communication"
author: "Rajesh"
date: "2025-12-17T10:00:00"
categories: [ros2, zenoh, workshop, roscon-india, security, networking]
image: "thumbnail.png"
toc: true
toc-depth: 3
code-fold: true
code-summary: "Show code"
---

## Series Overview

This is Part 2 of the Workshop 3 exercise preview:

| Part | Exercises | Focus |
|------|-----------|-------|
| Part 1 | 1-3 | Fundamentals: Pub/Sub, QoS, Shared Memory |
| **Part 2 (This Post)** | 4-5 | Remote: Cloud Router, mTLS Security |
| Part 3 | 6-8 | Advanced: Wireless, Congestion, NAT |

---

## Exercise 4: Remote Connectivity & Cloud Router

### The Problem: Robots Behind NAT

Most robots operate behind NAT (Network Address Translation) - they have private IP addresses that aren't directly reachable from the internet.

![The NAT Problem - Robots behind NAT cannot receive inbound connections from cloud servers](nat-problem.png){fig-alt="Diagram showing a robot with private IP behind NAT router, where outbound connections work but inbound connections are blocked"}

::: {.callout-note}
## Why Does NAT Block Inbound Connections?

**The Short Answer**: NAT only knows how to route *replies* to connections your robot *initiated*. It has no idea where to send unsolicited incoming packets.

**Step-by-Step Explanation**:

1. **Your robot has a private IP** (e.g., `192.168.1.50`) - this address only works inside your local network

2. **When robot sends data OUT**:
   - Robot sends packet: `192.168.1.50:5000 → 8.8.8.8:80`
   - NAT router rewrites it: `203.0.113.5:34567 → 8.8.8.8:80` (using router's public IP)
   - NAT creates a **translation entry**: "replies to port 34567 go to 192.168.1.50:5000"

3. **Replies come back successfully**:
   - Server replies: `8.8.8.8:80 → 203.0.113.5:34567`
   - NAT looks up port 34567, finds the entry, forwards to robot ✅

4. **But unsolicited INBOUND fails**:
   - Cloud server tries: `1.2.3.4:443 → 203.0.113.5:7447`
   - NAT asks: "Port 7447? I have no translation entry for this!"
   - Packet is **dropped** ❌

**The Key Insight**: NAT is like a receptionist who only connects calls if someone inside asked to speak to that caller first. Cold calls get rejected!
:::

**DDS limitation**: Relies on direct peer-to-peer connections. If peers can't reach each other, no communication.

### The Solution: Zenoh Cloud Router

Zenoh routers can be deployed **anywhere** - including cloud servers. Robots connect **outbound** to the cloud router, establishing a bidirectional channel.

![Zenoh Cloud Router Solution - All connections are outbound, solving the NAT problem](cloud-router-solution.png){fig-alt="Diagram showing robots and operators both connecting outbound to a central cloud router, enabling communication through NAT"}

::: {.callout-note}
## How Does Zenoh Solve the NAT Problem?

**The Short Answer**: Everyone connects OUTBOUND to a cloud router. Since all connections are outbound, NAT translation entries exist for everyone, and the router can relay messages between them.

**Step-by-Step Explanation**:

1. **Deploy a Zenoh router on a cloud server** with a public IP (e.g., `54.23.45.67`)
   - This server has no NAT - it's directly reachable from anywhere

2. **Robot connects OUTBOUND to router**:
   - Robot initiates: `192.168.1.50:5000 → 54.23.45.67:7447`
   - NAT creates translation entry ✅
   - Connection stays open (bidirectional TCP channel)

3. **Operator laptop ALSO connects OUTBOUND**:
   - Laptop initiates: `10.0.0.25:6000 → 54.23.45.67:7447`
   - Laptop's NAT creates translation entry ✅
   - Another bidirectional channel established

4. **Router relays messages between them**:
   - Laptop publishes `/cmd_vel` → Router receives it
   - Router forwards to Robot via the *already-open* channel
   - NAT allows it because Robot initiated that connection! ✅

**The Key Insight**: By having everyone connect OUT to a central point, we flip the problem. Instead of trying to reach robots (impossible through NAT), we let robots reach us and keep the channel open for bidirectional communication.
:::

**Why This Is Different From DDS**:

| DDS | Zenoh Router |
|-----|--------------|
| Discovery finds peers, then direct P2P | All traffic flows through router |
| Fails if either peer is behind NAT | Works as long as router is reachable |
| Requires multicast or unicast discovery | Explicit connection to known endpoint |


### Deployment Options

| Option | Pros | Cons |
|--------|------|------|
| **Self-hosted VPS** | Full control, low cost | Requires setup/maintenance |
| **Zenoh Cloud** | Managed, easy setup | Monthly cost |
| **Peer router** | No cloud needed | Both peers must be reachable |

### Key Insight: The Three Pillars of Zenoh Configuration

Understanding Zenoh configuration comes down to three essential pillars:

| Pillar | Description | Options |
|--------|-------------|---------|
| **Mode** | Role in the network | `client`, `peer`, `router` |
| **Connect/Listen** | How to find/accept connections | `tcp/127.0.0.1:7447`, `tcp/0.0.0.0:7447` |
| **Transport** | How data is moved | SHM, TCP, TLS, QUIC |

::: {.callout-important}
## Eureka Moment #1: Router Relays ALL Traffic

**Key Insight**: Unlike DDS where discovery leads to direct peer-to-peer connections, Zenoh router relays **ALL traffic** continuously.

```
DDS:    Discovery → Direct peer-to-peer (fails through NAT)
Zenoh:  All traffic through router (works through ANY NAT)
```

**Why this matters**: Both client and server connect **OUTBOUND** to the router. Neither needs to accept incoming connections. This is why Zenoh works through NAT/firewalls!
:::

::: {.callout-tip}
## Eureka Moment #2: One-Line Change for Remote

Going from local to remote connectivity is literally a one-line change:

```json5
// LOCAL
connect: { endpoints: ["tcp/127.0.0.1:7447"] }

// REMOTE (just change the IP!)
connect: { endpoints: ["tcp/cloud-server-ip:7447"] }
```

No VPN required. No firewall rules. No port forwarding. Just point to a cloud router!
:::

### Cloud Router Configuration

```json5
// cloud_router.json5 (on cloud server)
{
  mode: "router",
  listen: {
    endpoints: [
      "tcp/0.0.0.0:7447",    // Public TCP endpoint
      "tls/0.0.0.0:7448"     // TLS endpoint (for mTLS)
    ]
  },
  // Optional: Enable admin interface
  plugins: {
    rest: {
      http_port: 8000
    }
  }
}
```

```json5
// client_config.json5 (on robot)
{
  mode: "client",
  connect: {
    endpoints: [
      "tcp/your-cloud-server.com:7447"
    ]
  }
}
```

### Router Federation

Multiple routers can connect to each other, creating a **mesh network**:

![Router Federation - Global mesh network with routers in multiple regions](router-federation.png){fig-alt="World map showing Zenoh routers in US, EU, and Asia regions connected in a mesh, with robots connecting to their nearest router"}

### Hands-On Commands

```bash
# On cloud server: Start router
zenohd --config cloud_router.json5

# On robot: Connect as client
export ZENOH_CONFIG=/workshop3/configs/client_config.json5
ros2 run demo_nodes_cpp talker

# On laptop (different network): Subscribe via cloud
export ZENOH_CONFIG=/workshop3/configs/client_config.json5
ros2 run demo_nodes_cpp listener

# Verify connectivity
zenoh scout --config client_config.json5
```

---

## Exercise 5: mTLS Security

### Why Security Matters

Once your robot is reachable over the internet, **anyone** can potentially:
- Subscribe to your camera feeds
- Send commands to your robot
- Intercept sensitive data

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    SECURITY RISKS                                        │
│                                                                          │
│    Legitimate User         Cloud Router         Attacker                │
│    ┌─────────┐            ┌──────┐            ┌─────────┐              │
│    │ Control │────────────│      │────────────│ Eavesdrop│              │
│    │ Station │            │zenohd│            │ & Inject │              │
│    └─────────┘            └──────┘            └─────────┘              │
│                                                                          │
│    Without encryption: Attacker can see ALL messages                    │
│    Without authentication: Attacker can pretend to be legitimate       │
└─────────────────────────────────────────────────────────────────────────┘
```

### mTLS: Mutual TLS Authentication

**mTLS** (mutual TLS) provides both **encryption** and **authentication**:

| Feature | What It Does |
|---------|--------------|
| **Encryption** | All traffic encrypted with TLS |
| **Server Auth** | Client verifies router's identity |
| **Client Auth** | Router verifies client's identity |
| **Certificate-based** | No passwords to manage |

![mTLS Handshake - Both client and server exchange and verify certificates](mtls-handshake.png){fig-alt="Diagram showing the 5-step mTLS handshake process where both client and server present certificates before establishing an encrypted tunnel"}

::: {.callout-note}
## What Does mTLS Actually Provide?

**The Short Answer**: mTLS gives you encrypted communication where BOTH sides prove their identity using certificates - not just the server (like HTTPS), but the client too.

**Understanding the "Mutual" in mTLS**:

| Scenario | Server Proves Identity | Client Proves Identity | Example |
|----------|:---------------------:|:----------------------:|---------|
| **HTTP** (no TLS) | ❌ | ❌ | `http://example.com` |
| **HTTPS** (TLS) | ✅ | ❌ | `https://amazon.com` - you verify it's really Amazon |
| **mTLS** | ✅ | ✅ | Robot ↔ Router - both verify each other |

**Why Do Robots Need mTLS (not just TLS)?**

With regular TLS (like HTTPS):
- Your robot connects to the cloud router
- Robot verifies "yes, this is really my router" ✅
- But router has NO IDEA who connected - could be anyone! ❌

With mTLS:
- Robot verifies "this is really my router" ✅
- Router verifies "this is really my authorized robot" ✅
- Attackers without valid certificates are **rejected**

**What Certificates Prove**:

1. **Identity**: "I am robot-042 from fleet XYZ" (encoded in certificate)
2. **Authorization**: "I was issued this certificate by a trusted CA" (signature chain)
3. **Integrity**: "This certificate hasn't been tampered with" (cryptographic signature)

**Real-World Analogy**:
- **TLS** = Checking the bouncer's ID badge before entering a club
- **mTLS** = Bouncer checks YOUR ID too, and both IDs must be issued by the same trusted authority
:::


### Certificate Structure

![PKI Certificate Hierarchy - Root CA signs all device certificates](pki-hierarchy.png){fig-alt="Tree diagram showing Root CA at top with Router, Robot, and Operator certificates branching below, all signed by the same CA for mutual trust"}

### Generating Certificates (X.509 v3 Required!)

::: {.callout-note}
## Understanding Certificate Generation with OpenSSL

**The Short Answer**: You need to create a Certificate Authority (CA), then use it to sign certificates for your router and clients. Think of it as creating your own "ID card issuing office" and then issuing ID cards to authorized devices.

**The Three Files You Need Per Device**:

| File | What It Is | Who Sees It |
|------|-----------|-------------|
| `*.key` | **Private Key** - The secret! Used to prove identity | ONLY the device owner |
| `*.csr` | **Certificate Signing Request** - "Please sign my public key" | Sent to CA (temporary) |
| `*.pem` | **Certificate** - Signed public key + identity info | Everyone (it's public) |

**The Certificate Generation Flow**:

```
Step 1: Create CA (your "ID card office")
┌─────────────────────────────────────────────────┐
│  openssl genrsa → ca.key (CA's secret)          │
│  openssl req -x509 → ca.pem (CA's certificate)  │
└─────────────────────────────────────────────────┘
         │
         ▼
Step 2: For each device (router, robot, operator):
┌─────────────────────────────────────────────────┐
│  openssl genrsa → device.key (device's secret)  │
│  openssl req -new → device.csr (signing request)│
│  openssl x509 -req + CA signs → device.pem      │
└─────────────────────────────────────────────────┘
```

**Why Do We Need a CA?**

Without a CA, devices would have to know about every other device's certificate individually. With a CA:
- Devices only need to trust ONE certificate (the CA)
- Any certificate signed by that CA is automatically trusted
- Adding new devices = just sign a new certificate (no reconfiguration needed)
:::

::: {.callout-warning}
## Important: Zenoh Requires X.509 v3 Certificates
Basic OpenSSL commands create v1 certificates which will fail with `UnsupportedCertVersion` error. You must use the `-extfile` option to create v3 certificates.
:::

```bash
# Create working directory
mkdir -p /tmp/zenoh-certs && cd /tmp/zenoh-certs

# Create v3 extension config (REQUIRED for Zenoh!)
cat > v3.ext << 'EOF'
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, keyEncipherment
EOF

# 1. Generate CA (Certificate Authority) with v3 extensions
openssl genrsa -out ca.key 2048
openssl req -x509 -new -nodes -key ca.key -sha256 -days 365 \
    -out ca.pem -subj "/CN=Zenoh-Workshop-CA" \
    -addext "basicConstraints=critical,CA:TRUE"

# 2. Generate Router certificate (v3)
openssl genrsa -out server.key 2048
openssl req -new -key server.key -out server.csr -subj "/CN=zenoh-router"
openssl x509 -req -in server.csr -CA ca.pem -CAkey ca.key \
    -CAcreateserial -out server.pem -days 365 -sha256 \
    -extfile v3.ext

# 3. Generate Client certificate (v3)
openssl genrsa -out client.key 2048
openssl req -new -key client.key -out client.csr -subj "/CN=ros2-client"
openssl x509 -req -in client.csr -CA ca.pem -CAkey ca.key \
    -CAcreateserial -out client.pem -days 365 -sha256 \
    -extfile v3.ext

# 4. Verify certificate version is v3
openssl x509 -in server.pem -text -noout | grep "Version"
# Expected: Version: 3 (0x2)
```

### Zenoh TLS Configuration

::: {.callout-warning}
## Important: Zenoh 1.7.1 Config Field Names Changed!
The field names in Zenoh 1.7.1 are different from older documentation. Using old field names will cause "unknown field" errors.

| Old Name (wrong) | New Name (correct) |
|------------------|-------------------|
| `root_ca_certificate_file` | `root_ca_certificate` |
| `server_private_key_file` | `listen_private_key` |
| `server_certificate_file` | `listen_certificate` |
| `client_private_key_file` | `connect_private_key` |
| `client_certificate_file` | `connect_certificate` |
| `client_auth: true` | `enable_mtls: true` |
:::

```json5
// router_tls.json5
{
  mode: "router",
  listen: {
    endpoints: ["tls/0.0.0.0:7448"]
  },
  transport: {
    link: {
      tls: {
        root_ca_certificate: "/certs/ca.pem",
        listen_private_key: "/certs/server.key",
        listen_certificate: "/certs/server.pem",
        enable_mtls: true  // Require client certificates!
      }
    }
  }
}
```

```json5
// client_tls.json5
{
  mode: "client",
  connect: {
    endpoints: ["tls/your-server.com:7448"]
  },
  transport: {
    link: {
      tls: {
        root_ca_certificate: "/certs/ca.pem",
        connect_private_key: "/certs/client.key",
        connect_certificate: "/certs/client.pem"
      }
    }
  }
}
```

### Hands-On Commands

::: {.callout-note}
## Zenoh CLI Syntax
Global flags (like `--config`) must come **BEFORE** the subcommand:
```bash
zenoh --config config.json5 subscribe -k "key/**"  # ✅ Correct
zenoh subscribe --config config.json5 -k "key/**"  # ❌ Wrong (unrecognized arguments)
```
:::

```bash
# Start router with TLS (Terminal 1)
zenohd -c /tmp/zenoh-certs/router_tls.json5
# Expected: "Zenoh can be reached at: tls/172.20.10.11:7448"

# Subscribe with TLS using Zenoh CLI (Terminal 2)
zenoh --config /tmp/zenoh-certs/client_tls.json5 subscribe -k "test/**"
# Note: Output will be Base64 encoded

# Publish with TLS (Terminal 3)
zenoh --config /tmp/zenoh-certs/client_tls.json5 put -k "test/secure" -v "Hello via mTLS!"

# Decode Base64 message
echo "SGVsbG8gdmlhIG1UTFMh" | base64 -d
# Output: "Hello via mTLS!"

# Test REJECTION (no certificate - should FAIL!)
zenoh --connect "tls/127.0.0.1:7448" subscribe -k "test/**"
# Expected: Connection fails, router shows "BadCertificate" warning
```

### Verified Test Results

```
Terminal 1 (Router):   ✅ Listening on tls/172.20.10.11:7448
                       ⚠️ "BadCertificate" = blocking unauthorized connections!

Terminal 2 (Subscribe): ✅ Received: SGVsbG8gdmlhIG1UTFMh (base64 encoded)

Terminal 3 (Publish):   ✅ Message sent successfully
```

::: {.callout-tip}
## Understanding "BadCertificate" Warning
When you see this in the router logs:
```
received fatal alert: BadCertificate. Hint: increase the system open file limit.
```

**This is a SUCCESS indicator!** It means:

1. An unauthorized client tried to connect without valid certificates
2. The router correctly rejected the connection
3. Your mTLS security is working as intended

The "open file limit" hint is a generic message and **not relevant** to certificate validation failures. The BadCertificate alert confirms only clients with valid certificates signed by your CA can connect.
:::


### Security Best Practices

| Practice | Why |
|----------|-----|
| **Rotate certificates** | Limit exposure if key is compromised |
| **Use short-lived certs** | 30-90 days recommended |
| **Separate CAs per environment** | Dev, staging, prod should have different trust |
| **Never share private keys** | Each device gets unique key pair |
| **Monitor certificate expiry** | Automate renewal with tools like cert-manager |

::: {.callout-warning}
## Certificate Storage Locations

We used `/tmp/zenoh-certs/` for quick demos - this is **temporary storage** that gets cleared on reboot!

| Environment | Recommended Location |
|-------------|---------------------|
| **Development** | `./certs/` in project directory |
| **Linux Production** | `/etc/zenoh/certs/` (chmod 600) |
| **Docker** | Mount as volume from secure host path |
| **Kubernetes** | Mount as Secrets |

**Never store production certificates in `/tmp`!**
:::

::: {.callout-tip}
## Workshop Tip
The workshop provides pre-generated certificates for the exercises. In production, use a proper PKI or managed certificate service.
:::

---

## Combining Remote + Security

The real power comes from **combining** Exercises 4 and 5:

![Secure Remote Robot Access - Complete architecture combining cloud routing with mTLS](secure-remote-access.png){fig-alt="Architecture diagram showing field robot, cloud router with TLS, and operator laptop all connected with mTLS encryption, with checkmarks for NAT traversal, encryption, authentication, and no VPN required"}

---

## What's Next

In **Part 3**, we'll preview Exercises 6-8:
- **Exercise 6**: Wireless Performance Tuning
- **Exercise 7**: Congestion Handling
- **Exercise 8**: NAT Traversal & Namespace Resolution

These exercises tackle the **practical challenges** of real-world robot deployments over unreliable networks.

---

## Preparation Checklist

Before Workshop 3, make sure you understand:

- [ ] Why NAT blocks inbound connections
- [ ] How Zenoh routers solve the NAT problem
- [ ] What mTLS provides (encryption + mutual authentication)
- [ ] Basic certificate generation with OpenSSL

---

## Resources

- [Zenoh TLS Configuration](https://zenoh.io/docs/manual/tls/)
- [mTLS Explained](https://www.cloudflare.com/learning/access-management/what-is-mutual-tls/)
- [OpenSSL Certificate Guide](https://www.openssl.org/docs/man1.1.1/man1/openssl-req.html)
- [Let's Encrypt for TLS](https://letsencrypt.org/) (server certificates only)
