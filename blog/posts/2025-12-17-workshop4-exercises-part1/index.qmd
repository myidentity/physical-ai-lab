---
title: "Workshop 4 Preview: IMU Alone - Watching It Drift Away"
subtitle: "Part 1 of 4: Why Raw IMU Data Isn't Enough for Robot Navigation"
author: "Rajesh"
date: "2025-12-17T12:00:00"
categories: [ros2, imu, perception, workshop, roscon-india, realsense, d435i]
image: "thumbnail.png"
toc: true
toc-depth: 3
code-fold: true
code-summary: "Show code"
lightbox: true
---

## What This Series Covers

ROSCon India 2025 Workshop 4 by **Yaanendriya Pvt. Ltd.** features hands-on exercises in **IMU-Centric Perception**. This 4-part preview series takes you through the complete problem domain using the Intel RealSense D435i.

| Part | Stage | Focus | Key Learning |
|------|-------|-------|--------------|
| **Part 1 (This Post)** | IMU Only | Raw IMU problems | Why IMU alone isn't enough |
| Part 2 | Vision Only | Visual odometry problems | Why vision alone fails |
| Part 3 | Fusion (VIO) | Combining strengths | How fusion solves both |
| Part 4 | Workshop Prep | yDx.M context | What Yaanendriya adds |

::: {.callout-note}
## The Learning Journey
We'll experience the **exact problems** that motivated professional IMU solutions like Yaanendriya's yDx.M module. By struggling with these issues firsthand, we'll deeply appreciate the solutions the workshop will teach.
:::

---

## The D435i: Our IMU Testing Platform

The Intel RealSense D435i combines a depth camera with a built-in **6-DOF IMU** (Bosch BMI055). This makes it perfect for experiencing IMU problems before adding vision fusion.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      INTEL REALSENSE D435i                              â”‚
â”‚                                                                         â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    â”‚                    Hardware Components                        â”‚    â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚    â”‚   RGB Camera       â”‚   Stereo Depth     â”‚   IMU (BMI055)     â”‚    â”‚
â”‚    â”‚   1920Ã—1080@30fps  â”‚   1280Ã—720@90fps   â”‚   400 Hz           â”‚    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                         â”‚
â”‚    IMU Specs:                                                          â”‚
â”‚    â€¢ Accelerometer: Â±2/4/8/16G, 12-bit                                â”‚
â”‚    â€¢ Gyroscope: Â±2000Â°/s, 16-bit                                      â”‚
â”‚    â€¢ Output Rate: Up to 400 Hz                                        â”‚
â”‚    â€¢ âš ï¸ NOT factory calibrated!                                       â”‚
â”‚    â€¢ âš ï¸ No magnetometer (6-DOF only)                                  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Experiment 1: Raw IMU Has No Orientation!

### What You'll Experience

The first shock: **raw IMU data doesn't include orientation**. The sensor outputs acceleration and angular velocity, but not roll-pitch-yaw!

### Launch the Container

```bash
# Launch Workshop 4 container
./scripts/launch-container.sh 4

# Inside container - start RealSense with IMU enabled
ros2 launch realsense2_camera rs_launch.py \
    enable_gyro:=true \
    enable_accel:=true \
    unite_imu_method:=2
```

### RealSense Launch Output

When you launch, you'll see output like this:

```
[INFO] [camera.camera]: Device with name Intel RealSense D435I was found.
[INFO] [camera.camera]: Device Serial No: 317222070886
[INFO] [camera.camera]: Device FW version: 5.13.0.50
[INFO] [camera.camera]: Set ROS param gyro_fps to default: 200
[INFO] [camera.camera]: Set ROS param accel_fps to default: 100
[INFO] [camera.camera]: Starting Sensor: Motion Module
WARNING [ds-calib-parsers.cpp:36] IMU Calibration is not available,
        default intrinsic and extrinsic will be used.
[INFO] [camera.camera]: Open profile: stream_type: Accel(0)Format: MOTION_XYZ32F, FPS: 100
[INFO] [camera.camera]: Open profile: stream_type: Gyro(0)Format: MOTION_XYZ32F, FPS: 200
[INFO] [camera.camera]: RealSense Node Is Up!
```

::: {.callout-warning}
## Notice the WARNING!
**"IMU Calibration is not available"** - This confirms the D435i IMU is NOT factory calibrated. We'll explore this in Experiment 5!
:::

### Check the IMU Topic

```bash
# List IMU topics
ros2 topic list | grep -E "(imu|accel|gyro)"
# Expected:
# /camera/camera/imu
# /camera/camera/accel/sample
# /camera/camera/gyro/sample

# Echo the combined IMU topic
ros2 topic echo /camera/camera/imu --once
```

### The Shocking Result

**Actual output from our D435i** (December 17, 2025):

```yaml
header:
  stamp:
    sec: 1765940863
    nanosec: 540482304
  frame_id: camera_imu_optical_frame
orientation:
  x: 0.0
  y: 0.0
  z: 0.0
  w: 0.0   # â† ALL ZEROS! No orientation computed!
orientation_covariance:
- -1.0     # â† This -1 means "orientation NOT PROVIDED"
- 0.0
- 0.0
# ... (rest are zeros)
angular_velocity:
  x: -0.024434609338641167    # rad/s - real rotation rate!
  y: -0.001745329238474369
  z: 0.0
linear_acceleration:
  x: 0.13729310035705566      # m/sÂ² - real acceleration!
  y: -9.443803787231445       # â† Gravity component (camera tilted!)
  z: -2.5399222373962402      # â† Gravity component
```

Notice the camera is tilted ~70Â° - gravity is split between Y and Z axes!

::: {.callout-important}
## The Problem: Raw IMU â‰  Orientation

The RealSense driver publishes **raw sensor readings**:
- âœ… `angular_velocity` - How fast we're rotating (rad/s)
- âœ… `linear_acceleration` - Forces on the sensor (m/sÂ²)
- âŒ `orientation` - **All zeros!**

The `orientation_covariance[0] = -1` tells ROS 2: *"orientation field is not provided"*
:::

### Why This Matters

Many ROS 2 packages (like `robot_localization`, Nav2) expect IMU messages **with valid orientation**. They'll fail or behave incorrectly with zeros!

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     RAW IMU vs FILTERED IMU                             â”‚
â”‚                                                                         â”‚
â”‚    RAW (from sensor)              FILTERED (after processing)          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚    â”‚ angular_velocityâ”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ angular_velocityâ”‚                  â”‚
â”‚    â”‚ linear_accel    â”‚  Filter    â”‚ linear_accel    â”‚                  â”‚
â”‚    â”‚ orientation: 0  â”‚  (Madgwick)â”‚ orientation: âœ“  â”‚                  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                                         â”‚
â”‚    Problem: Most ROS 2 packages need the filtered version!             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Eureka Moment #1

::: {.callout-tip}
## Raw IMU sensors output rates, not states!

**Accelerometer**: Measures **force** (including gravity) â†’ Need to integrate for velocity
**Gyroscope**: Measures **rotation rate** â†’ Need to integrate for orientation

A **filter** (like Madgwick) combines both to **compute orientation**. This is Exercise 2!
:::

---

## Experiment 2: Running the Madgwick Filter

### What You'll Learn

The Madgwick filter is a popular AHRS (Attitude and Heading Reference System) algorithm that computes orientation from raw IMU data.

### Install and Run

```bash
# The filter is pre-installed in workshop4-imu container
# Terminal 1: RealSense with IMU
ros2 launch realsense2_camera rs_launch.py \
    enable_gyro:=true enable_accel:=true unite_imu_method:=2

# Terminal 2: Run Madgwick filter
ros2 run imu_filter_madgwick imu_filter_madgwick_node --ros-args \
    -r imu/data_raw:=/camera/camera/imu \
    -p use_mag:=false \
    -p publish_tf:=true \
    -p world_frame:=enu
```

### Check the Filtered Output

```bash
# Now check the filtered IMU topic
ros2 topic echo /imu/data --field orientation
```

**Now we see real orientation!** Actual output from our test:

```yaml
header:
  stamp:
    sec: 1765940920
    nanosec: 373782272
  frame_id: camera_imu_optical_frame
orientation:
  x: -0.5715487262389173    # â† Real values!
  y: 0.557508732210737
  z: -0.4266440447846019
  w: 0.42484223671061966    # â† Valid quaternion!
orientation_covariance:
- 0.0    # â† No longer -1! Filter provides orientation
# ...
```

**Before Madgwick**: `orientation = (0, 0, 0, 0)` âŒ
**After Madgwick**: `orientation = (-0.57, 0.56, -0.43, 0.42)` âœ…

### Visualize in RViz2

```bash
rviz2
# Add displays:
# - TF (to see the imu frame)
# - Axes (to visualize orientation)
# Set fixed frame to: camera_link
```

### The Filter in Action

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MADGWICK FILTER INTERNALS                            â”‚
â”‚                                                                         â”‚
â”‚    Gyroscope (Ï‰)                                                       â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                       â”‚
â”‚    â”‚ Ï‰x, Ï‰y, Ï‰zâ”‚â”€â”€â”€â”€â”€â”                                                 â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚                      â”œâ”€â”€â”€â”€â”€â–ºâ”‚                  â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚    Accelerometer (a) â”‚      â”‚ Madgwick Filter  â”‚â”€â”€â”€â”€â–ºâ”‚ Orientation  â”‚  â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚      â”‚ (quaternion math)â”‚     â”‚ (q: w,x,y,z) â”‚  â”‚
â”‚    â”‚ ax, ay, azâ”‚â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                       â”‚
â”‚                                                                         â”‚
â”‚    Key insight: Accelerometer provides gravity reference (down)        â”‚
â”‚                 Gyroscope integrates rotation over time                â”‚
â”‚                 Filter balances both for stable orientation            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Eureka Moment #2

::: {.callout-tip}
## The Filter Gives Us Orientation!

- **Before Madgwick**: orientation = (0, 0, 0, 0)
- **After Madgwick**: orientation = valid quaternion

The filter uses:
1. **Gyroscope** - integrates to get rotation
2. **Accelerometer** - uses gravity as "down" reference
3. **Sensor fusion** - balances fast gyro with stable accel

But there's still a problem... (see Experiment 3!)
:::

---

## Experiment 3: Yaw Drift Without Magnetometer

### The Hidden Problem

Rotate the camera **360Â° around the vertical axis** and return to the starting position. Watch what happens to yaw!

### The Test

```bash
# Terminal 1: RealSense + Madgwick (same as above)
# Terminal 2: Watch RPY (Roll-Pitch-Yaw)
ros2 topic echo /imu/rpy/filtered
```

### Procedure

1. Note the starting yaw value
2. Slowly rotate the camera 360Â° horizontally
3. Return to the exact starting position
4. Check yaw again

### Actual Console Output - Yaw Drift Test

We monitored Roll-Pitch-Yaw while keeping the camera **completely stationary**:

```
Monitoring YAW DRIFT for 10 seconds...
Keep camera STATIONARY to see drift!

  Time     Roll      Pitch      Yaw      Yaw Drift
-------------------------------------------------------
   0.0s   -106.13     -0.81    -75.83     +0.0000
   0.5s   -106.12     -0.79    -75.78     +0.0454
   1.0s   -106.10     -0.78    -75.75     +0.0828
   1.5s   -106.17     -0.78    -75.71     +0.1185
   2.0s   -106.10     -0.80    -75.67     +0.1559
   3.0s   -106.07     -0.77    -75.61     +0.2203
   4.0s   -106.12     -0.76    -75.53     +0.3014
   5.0s   -106.15     -0.76    -75.44     +0.3847
   6.0s   -106.09     -0.77    -75.36     +0.4654
   7.0s   -106.12     -0.79    -75.28     +0.5497
   8.0s   -106.12     -0.82    -75.20     +0.6298
   9.0s   -106.13     -0.80    -75.13     +0.7012
  10.0s   -106.12     -0.75    -75.06     +0.7723
-------------------------------------------------------

STATIONARY YAW DRIFT: +0.8171 degrees over 10 seconds
DRIFT RATE: +4.6712 degrees/minute
```

**Key observations:**
- **Roll**: Stable at -106Â° (camera is tilted on its side) âœ…
- **Pitch**: Stable at -0.8Â° âœ…
- **Yaw**: Drifting from -75.83Â° â†’ -75.06Â° even while stationary! âŒ

At this rate: **~4.7Â°/minute = 280Â° drift per hour!**

::: {.callout-warning}
## Yaw Drift: The Magnetometer Problem

**Roll** and **Pitch** are stable because gravity provides an absolute reference (accelerometer knows which way is down).

**Yaw** has NO absolute reference! The D435i has no magnetometer to tell which way is north.

- Every rotation accumulates small errors
- Over time, yaw drifts unboundedly
- 360Â° rotation might report 370Â°, 350Â°, or worse!
:::

### Why This Happens

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    YAW DRIFT PROBLEM (6-DOF IMU)                        â”‚
â”‚                                                                         â”‚
â”‚    Roll (rotation around X):                                           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     Gravity provides                                    â”‚
â”‚    â”‚ Stable! â”‚ â—„â”€â”€ absolute "down" reference                           â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                         â”‚
â”‚                                                                         â”‚
â”‚    Pitch (rotation around Y):                                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     Gravity provides                                    â”‚
â”‚    â”‚ Stable! â”‚ â—„â”€â”€ absolute "down" reference                           â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                         â”‚
â”‚                                                                         â”‚
â”‚    Yaw (rotation around Z - vertical):                                 â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     NO absolute reference!                              â”‚
â”‚    â”‚ DRIFTS! â”‚ â—„â”€â”€ Gyro integration only = accumulated error           â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                         â”‚
â”‚                                                                         â”‚
â”‚    Solution: Magnetometer (9-DOF) provides "north" reference           â”‚
â”‚              â†’ yDx.M offers 9/10-DOF configurations!                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Eureka Moment #3

::: {.callout-tip}
## 6-DOF vs 9-DOF: The Yaw Problem

| IMU Type | Sensors | Yaw Reference | Drift |
|----------|---------|---------------|-------|
| **6-DOF** (D435i) | Accel + Gyro | None! | Unbounded |
| **9-DOF** (with mag) | Accel + Gyro + Mag | Magnetic North | Bounded |

The yDx.M module from Yaanendriya offers **9/10-DOF configurations** with magnetometer - solving this exact problem!
:::

---

## Experiment 4: Dead-Reckoning Disaster

### The Ultimate IMU Failure

What if we try to track **position** by integrating acceleration? This is called "dead-reckoning."

### The Math (In Theory)

```
Position = âˆ«âˆ« Acceleration dtÂ²

1. Measure acceleration (a)
2. Integrate to get velocity: v = âˆ« a dt
3. Integrate again to get position: p = âˆ« v dt
```

### The Reality

```bash
# We'll use robot_localization to fuse IMU â†’ position
# Create a minimal EKF config that uses ONLY IMU

cat > /tmp/imu_only_ekf.yaml << 'EOF'
ekf_filter_node:
  ros__parameters:
    frequency: 50.0
    sensor_timeout: 0.1
    two_d_mode: false

    map_frame: map
    odom_frame: odom
    base_link_frame: base_link
    world_frame: odom

    # IMU only - fusing acceleration to get position
    imu0: /imu/data
    imu0_config: [false, false, false,   # Don't use position (IMU has none)
                  true,  true,  true,    # Use orientation (roll, pitch, yaw)
                  false, false, false,   # Don't use velocity directly
                  true,  true,  true,    # Use angular velocity
                  true,  true,  true]    # Use linear acceleration
    imu0_differential: false
    imu0_remove_gravitational_acceleration: true
EOF

# Run EKF
ros2 run robot_localization ekf_node --ros-args \
    --params-file /tmp/imu_only_ekf.yaml
```

### Watch Position Drift

```bash
# In another terminal - watch the odometry output
ros2 topic echo /odometry/filtered --field pose.pose.position
```

### Actual Console Output - The Disaster Unfolds

We integrated acceleration to compute position with the camera **sitting perfectly still**:

```
DEAD RECKONING - Integrating acceleration to get position
Camera should be STATIONARY - watch position drift!

  Time      Position (m)                    Velocity (m/s)
          X        Y        Z            Vx       Vy       Vz
------------------------------------------------------------------------
   1.0s     0.068   -4.707   -1.345        0.135   -9.367   -2.676
   2.0s     0.270  -18.783   -5.366        0.268  -18.736   -5.352
   3.0s     0.606  -42.226  -12.064        0.403  -28.100   -8.029
   5.0s     1.681 -117.200  -33.484        0.672  -46.834  -13.381
  10.0s     6.733 -468.597 -133.859        1.348  -93.675  -26.757
  15.0s    15.157 -1054.147 -301.123        2.021 -140.508  -40.136
  20.0s    26.887 -1869.728 -534.111        2.692 -187.135  -53.459
  25.0s    41.974 -2917.539 -833.429        3.366 -233.772  -66.778
  30.0s    60.420 -4198.513 -1199.342        4.039 -280.437  -80.107
------------------------------------------------------------------------

FINAL POSITION ERROR: 4385.88 meters (should be 0!)
Camera was STATIONARY but IMU thinks it moved 4385.9 meters!
```

**The camera never moved, yet the IMU computed:**
- Position drift: **4.4 KILOMETERS** in 30 seconds!
- Velocity error: **280 m/s** (faster than a race car!)
- This is completely unusable for navigation!

::: {.callout-important}
## Double Integration Amplifies Error

The problem: **noise integrates!**

1. Accelerometer has tiny bias: 0.01 m/sÂ²
2. After 1 second: velocity error = 0.01 m/s
3. After 10 seconds: velocity error = 0.1 m/s
4. Position error grows **quadratically** with time!

```
Error âˆ tÂ²  (quadratic growth!)
```

After 60 seconds with 0.01 m/sÂ² bias:
- Velocity error: 0.6 m/s
- Position error: ~18 meters! ðŸ¤¯
:::

### Eureka Moment #4

::: {.callout-tip}
## Dead-Reckoning With IMU Alone = Disaster

**Why IMU can't give position:**
1. Tiny accelerometer bias â†’ velocity drift
2. Velocity drift â†’ position drift (squared!)
3. Within seconds: meters of error
4. No way to correct without external reference

**This is why we need sensor fusion** (Part 3) - visual odometry provides position corrections!
:::

---

## Experiment 5: The Calibration Reality

### Uncalibrated vs Calibrated

The D435i IMU is **NOT factory calibrated**. Let's see the difference!

### Measure Stationary Noise

```bash
# Place camera on flat, stable surface
# Record 10 seconds of IMU data

ros2 bag record /camera/camera/imu -o imu_stationary --duration 10

# Analyze the variance
ros2 bag play imu_stationary &
ros2 topic echo /camera/camera/imu --field linear_acceleration | head -100
```

### What You'll See (Uncalibrated)

```yaml
# Should be [0, 0, 9.81] on flat surface
linear_acceleration:
  x: 0.142    # â† Should be ~0
  y: -0.087   # â† Should be ~0
  z: 9.73     # â† Should be ~9.81

# This bias will cause drift!
```

### Run Intel Calibration

```bash
# Use the Intel RealSense Viewer
realsense-viewer

# Navigate to:
# More â†’ On-chip Calibration â†’ Calibrate IMU
# Follow the instructions (keep camera still, then rotate)
```

### After Calibration

```yaml
linear_acceleration:
  x: 0.003    # â† Much better!
  y: 0.002    # â† Much better!
  z: 9.807    # â† Closer to 9.81!
```

### Eureka Moment #5

::: {.callout-tip}
## Calibration Reduces Bias (But Doesn't Eliminate It)

| Metric | Before Cal | After Cal | Improvement |
|--------|------------|-----------|-------------|
| X bias | 0.142 m/sÂ² | 0.003 m/sÂ² | 47x better |
| Y bias | 0.087 m/sÂ² | 0.002 m/sÂ² | 43x better |
| Z error | 0.08 m/sÂ² | 0.003 m/sÂ² | 27x better |

**yDx.M is factory calibrated** - one less thing to worry about at the workshop!
:::

---

## Experiment 6: Coordinate Frame Confusion

### ENU vs NED: The Silent Disaster

ROS 2 uses **ENU** (East-North-Up) frame convention. Aviation uses **NED** (North-East-Down). Mixing them causes chaos!

### The Test

```bash
# Check what frame the Madgwick filter outputs
ros2 run imu_filter_madgwick imu_filter_madgwick_node --ros-args \
    -r imu/data_raw:=/camera/camera/imu \
    -p world_frame:=enu   # ROS standard

# Compare with NED (wrong for ROS!)
ros2 run imu_filter_madgwick imu_filter_madgwick_node --ros-args \
    -r imu/data_raw:=/camera/camera/imu \
    -p world_frame:=ned   # Aviation standard
```

### What Happens with Wrong Frame

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COORDINATE FRAME MISMATCH                            â”‚
â”‚                                                                         â”‚
â”‚    ENU (ROS Standard)              NED (Aviation Standard)             â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚    â”‚     Y (North)   â”‚             â”‚     X (North)   â”‚                 â”‚
â”‚    â”‚        â†‘        â”‚             â”‚        â†‘        â”‚                 â”‚
â”‚    â”‚        â”‚        â”‚             â”‚        â”‚        â”‚                 â”‚
â”‚    â”‚   â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â–º X â”‚             â”‚   â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â–º Y â”‚                 â”‚
â”‚    â”‚    (East)       â”‚             â”‚    (East)       â”‚                 â”‚
â”‚    â”‚    Z: Up âŠ™      â”‚             â”‚    Z: Down âŠ—    â”‚                 â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                         â”‚
â”‚    If robot_localization expects ENU but receives NED:                 â”‚
â”‚    â†’ Robot appears UPSIDE DOWN in RViz!                                â”‚
â”‚    â†’ Position estimates are inverted!                                  â”‚
â”‚    â†’ Navigation fails catastrophically!                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Eureka Moment #6

::: {.callout-tip}
## Frame Conventions Matter!

| Package | Expected Frame | Standard |
|---------|----------------|----------|
| `robot_localization` | ENU | REP-103 |
| `Nav2` | ENU | REP-103 |
| Most IMU drivers | Configurable | Check docs! |
| Aviation software | NED | Not ROS! |

Always verify:
```bash
ros2 param get /imu_filter_madgwick world_frame
# Should return: "enu" for ROS 2 compatibility
```
:::

---

## Experiment 7: Understanding Covariance

### Why Covariance Matrices Matter

Every `sensor_msgs/Imu` message has three 3Ã—3 covariance matrices. These tell filters how much to **trust** each measurement.

### Check the Covariances

```bash
ros2 topic echo /imu/data --field orientation_covariance
ros2 topic echo /imu/data --field angular_velocity_covariance
ros2 topic echo /imu/data --field linear_acceleration_covariance
```

### What They Mean

```
Covariance Matrix (3x3, stored as 9 elements row-major):
â”Œ                   â”
â”‚ Ïƒxx  Ïƒxy  Ïƒxz     â”‚   Ïƒxx = variance of x measurement
â”‚ Ïƒyx  Ïƒyy  Ïƒyz     â”‚   Ïƒyy = variance of y measurement
â”‚ Ïƒzx  Ïƒzy  Ïƒzz     â”‚   Ïƒzz = variance of z measurement
â””                   â”˜   Off-diagonal = correlation

Small values (0.001) = High confidence, trust this data
Large values (1.0)   = Low confidence, don't trust as much
```

### The Impact on Filtering

```bash
# With proper covariances - EKF works well
imu0_config: [false, false, false,
              true,  true,  true,    # orientation
              false, false, false,
              true,  true,  true,    # angular velocity
              true,  true,  true]    # acceleration

# Wrong covariances cause:
# - Filter divergence (estimates explode)
# - Sluggish response (overestimated covariance)
# - Overconfident (underestimated covariance â†’ crashes)
```

### Eureka Moment #7

::: {.callout-tip}
## Covariances Are Your Filter's Trust Settings

| Covariance | Effect on Filter |
|------------|------------------|
| Too small | Filter trusts noisy data â†’ oscillation |
| Too large | Filter ignores good data â†’ slow response |
| Just right | Optimal sensor fusion |

**yDx.M advantage**: Yaanendriya likely provides calibrated covariance values tuned for their hardware!
:::

---

## Summary: 7 Problems With IMU Alone

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              PART 1 SUMMARY: WHY IMU ALONE FAILS                        â”‚
â”‚                                                                         â”‚
â”‚   Problem #1: Raw IMU has no orientation (zeros!)                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚   Solution: Use filter (Madgwick, complementary)                       â”‚
â”‚                                                                         â”‚
â”‚   Problem #2: Yaw drifts without magnetometer                          â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚   Solution: 9-DOF IMU with magnetometer (yDx.M)                        â”‚
â”‚                                                                         â”‚
â”‚   Problem #3: Position drift from integration                          â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚   Solution: Sensor fusion with visual odometry (Part 3!)               â”‚
â”‚                                                                         â”‚
â”‚   Problem #4: Uncalibrated sensors have bias                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚   Solution: Run calibration OR use factory-calibrated IMU              â”‚
â”‚                                                                         â”‚
â”‚   Problem #5: Frame convention mismatches                              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚   Solution: Ensure ENU frame throughout ROS 2 pipeline                 â”‚
â”‚                                                                         â”‚
â”‚   Problem #6: Wrong covariances = bad fusion                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚   Solution: Tune covariances or use manufacturer values                â”‚
â”‚                                                                         â”‚
â”‚   Problem #7: Single point of failure                                  â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚   Solution: Distributed sensing (yDx.M network feature!)               â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## What's Next: The Cliffhanger

We've seen that IMU alone has serious limitations:
- No absolute yaw reference
- Position drifts in seconds
- Needs calibration and proper filtering

**But wait - we have a camera too!**

In **Part 2**, we'll try using **vision-only** approaches:
- Visual odometry with RTAB-Map
- What happens when we shake the camera?
- What happens with textureless walls?

Spoiler: Vision has its **own set of problems**... but they're *different* problems. This sets up Part 3 where we'll combine both for **robust Visual-Inertial Odometry (VIO)**!

---

## Preparation Checklist

Before Workshop 4, make sure you can:

- [ ] Launch RealSense with IMU: `enable_gyro:=true enable_accel:=true`
- [ ] Run Madgwick filter and see orientation output
- [ ] Understand why raw IMU has no orientation
- [ ] Experience yaw drift during rotation
- [ ] Know why position estimation fails with IMU alone
- [ ] Understand ENU vs NED frame conventions
- [ ] Verify IMU covariances in message

---

## About Yaanendriya's yDx.M

The workshop will feature Yaanendriya's **yDx.M** module - here's how it addresses today's problems:

| D435i Problem | yDx.M Solution |
|---------------|----------------|
| No orientation from raw IMU | Built-in AHRS |
| Yaw drift (no magnetometer) | 9/10-DOF with magnetometer |
| Manual calibration required | Factory calibrated |
| Single sensor failure | Distributed sensor network |
| Covariance tuning | Pre-tuned for hardware |

We're building understanding of the problems - the workshop will show us the professional solutions!

---

## Resources

- [REP-145: IMU Sensor Driver Conventions](https://www.ros.org/reps/rep-0145.html)
- [imu_filter_madgwick](https://index.ros.org/p/imu_filter_madgwick/)
- [D435i IMU Calibration](https://www.intelrealsense.com/wp-content/uploads/2019/07/Intel_RealSense_Depth_D435i_IMU_Calibration.pdf)
- [robot_localization Documentation](http://docs.ros.org/en/melodic/api/robot_localization/html/)
